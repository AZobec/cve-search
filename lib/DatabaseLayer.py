#!/usr/bin/env python3.3
# -*- coding: utf-8 -*-
#
# Database layer
#  translates database calls to functions
#
# Software is free software released under the "Modified BSD license"
#

# Copyright (c) 2014-2015       Pieter-Jan Moreels - pieterjan.moreels@gmail.com

# imports
from lib.Config import Configuration as conf
import pymongo

# Variables
db=conf.getMongoConnection()
colCVE=      db['cves']
colCPE=      db['cpe']
colCPEOTHER= db['cpeother']
colWHITELIST=db['mgmt_whitelist']
colBLACKLIST=db['mgmt_blacklist']
colUSERS=    db['mgmt_users']
colSEEN=     db['mgmt_seen']
colINFO=     db['info']
# Functions
def sanitize(x):
  if type(x)==pymongo.cursor.Cursor:
    x=list(x)
  if type(x)==list:
    for y in x: sanitize(y)
#  if x:
  if "_id" in x: x.pop("_id")
  return x

# DB Functions
def setColUpdate(collection, date):
  colINFO.update({"db": collection}, {"$set": {"last-modified": date}}, upsert=True)

def insertCVE(cve):
  colCVE.insert(cve)

def updateCVE(cve):
  colCVE.update({"id": cve['id']}, {"$set": {"cvss": cve['cvss'], "summary": cve['summary'], "references": cve[' references'],
                                             "cwe": cve['cwe'], "vulnerable_configuration": cve['vulnerable_configuration'],
                                             "vulnerable_configuration_cpe_2_2": cve['vulnerable_configuration_cpe_2_2'], 'last-modified': cve['Modified']}})

# API Functions
def cvesForCPE(cpe):
  if not cpe: return []
  return sanitize(colCVE.find({"vulnerable_configuration": {"$regex": cpe}}).sort("Modified", -1))

# User Functions
def seenCVEs(user):
  data = colSEEN.find_one({"user": user})
  if not data:
    colSEEN.insert({"user": user, "seen_cves": []})
    return []
  else:
    return data['seen_cves']

def addSeenCVEs(user, CVEs):
  if type(CVEs) == str: CVEs=[CVEs]
  if type(CVEs) == list:
    seen=list(set(CVEs)-set(seenCVEs(user)))
    if seen:
      colSEEN.update({"user": user},{"$addToSet": {"seen_cves": { "$each": seen}}})

def removeSeenCVEs(user, CVEs):
  if type(CVEs) == str: CVEs=[CVEs]
  if type(CVEs) == list:
    colSEEN.update({"user": user}, {"$pullAll": {"seen_cves": CVEs}})

def isMasterAccount(user):
  return False if colUSERS.find({"username": user, "master": True}).count() == 0 else True

def userExists(user):
  return True if colUSERS.find({"username": user}).count() > 0 else False

def isSingleMaster(user):
  return True if len(list(colUSERS.find({"username": {"$ne": user}, "master": True}))) == 0 else False

# Query Functions
# Generic data
def getCVEs(limit=-1, query=[], skip=0):
  if type(query) == dict: query=[query]
  if len(query) == 0:
    cves=colCVE.find().sort("Modified", -1).limit(limit).skip(skip)
  elif len(query)  == 1:
    cves=colCVE.find(query[0]).sort("Modified", -1).limit(limit).skip(skip)
  else:
    cves=colCVE.find({"$and": query}).sort("Modified", -1).limit(limit).skip(skip)
  return sanitize(cves)

def getCVE(id):
  return sanitize(colCVE.find_one({"id": id}))

def getCPE(id):
  return sanitize(colCPE.find_one({"id": id}))

def getAlternativeCPE(id):
  return sanitize(colCPEOTHER.find_one({"id": id}))

def getFreeText(text):
  return [x["obj"] for x in db.command("text", "cves", search=text)["results"]]

def getInfo(collection):
  return sanitize(colINFO.find_one({"db": collection}))

# Dynamic data
def getWhitelist():
  return sanitize(colWHITELIST.find())

def getRules(list):
  if list.lower()=='whitelist':
    col=colWHITELIST
  elif list.lower()=='blacklist':
    col=colBLACKLIST
  else:
    return []
  rlist=col.find({'type':'cpe'}).distinct('id')
  hardware=["cpe:2.3:([^:]*:){9}"+re.escape(x) for x in col.find({'type':'cpe'}).distinct('id')]
  software=["cpe:2.3:([^:]*:){8}"+re.escape(x) for x in col.find({'type':'cpe'}).distinct('id')]
  rlist.extend(hardware)
  rlist.extend(software)
  return rlist


def getBlacklist():
  return sanitize(colBLACKLIST.find())

# Users
def getUsers():
  return sanitize(colUSERS.find())

def getUser(user):
  return sanitize(colUSERS.find_one({"username": user}))
