import threading
import time
from abc import ABC, abstractmethod
from concurrent.futures.thread import ThreadPoolExecutor
from datetime import timedelta

import requests

thread_local = threading.local()


class DownloadHandler(ABC):

    def __init__(self):
        pass

    def __repr__(self):
        """ return string representation of object """
        return "<< DownloadHandler:{} >>"

    def get_session(self):
        if not hasattr(thread_local, "session"):
            thread_local.session = requests.Session()
        return thread_local.session

    def process_downloads(self, sites):
        start_time = time.time()
        with ThreadPoolExecutor() as executor:
            executor.map(self.download_site, sites)

        print("Duration: {}".format(timedelta(seconds=time.time() - start_time)))

    def chunk_list(self, lst, number):
        """Yield successive n-sized chunks from lst."""
        for i in range(0, len(lst), number):
            yield lst[i:i + number]

    def process_chunks_in_function(self, function, chunks, max_workers=None):
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            executor.map(function, chunks)

    @abstractmethod
    def download_site(self, **kwargs):
        pass

    @abstractmethod
    def stream_json(self, **kwargs):
        pass

    @abstractmethod
    def update(self, **kwargs):
        pass

    @abstractmethod
    def populate(self, **kwargs):
        pass
