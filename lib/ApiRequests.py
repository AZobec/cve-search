import json
import logging
from abc import ABC, abstractmethod
from datetime import datetime

from bson import json_util
from dicttoxml import dicttoxml
from flask import Response

from lib.LogHandler import ApiRequestHandler

logging.setLoggerClass(ApiRequestHandler)


def convertDatetime(dct=None):
    if isinstance(dct, (list, tuple, set)):
        for item in dct:
            convertDatetime(item)
    elif type(dct) is dict:
        for key, val in dct.items():
            if isinstance(val, datetime):
                dct[key] = val.isoformat()
            if isinstance(val, (dict, list)):
                convertDatetime(val)
    return dct


class ApiRequest(ABC):
    def __init__(self):
        self._request_results = None

    @abstractmethod
    def process(self, **kwargs):
        raise NotImplementedError

    @property
    def request_results(self):
        return self._request_results

    @request_results.setter
    def request_results(self, the_results):
        self._request_results = {"total": len(the_results), "data": the_results}


class JSONApiRequest(ApiRequest):
    def __init__(self, headers, body):
        """
        Main class for the JSONApiRequest endpoints of the api.

        :param headers: Request headers
        :type headers: dict
        :param body: JSON query body
        :type body: dict
        """
        super().__init__()
        self.logger = logging.getLogger(__name__)

        self.request_headers = headers
        self.body = body

    def process(self, database_connection):
        """
        Method to process the request

        :param database_connection: Hookup to the database
        :type database_connection: DatabaseHandler
        :return: Results from the request
        :rtype: list
        """
        self.logger.debug(
            "Processing request: {}  Headers received: {}".format(
                self.body, self.request_headers
            )
        )

        validated, reason = self.validate_body()

        if not validated:
            self.logger.warning(
                "Validation on {} not succeeded: {}".format(self.body, reason)
            )
            return Response(reason, mimetype="application/json"), 400
        else:

            retrieve = self.body.pop("retrieve")

            if "output_format" in self.body.keys():
                output_format = self.body.pop("output_format")
            else:
                output_format = "json"

            results = getattr(
                database_connection, "store_{}".format(retrieve)
            ).query_docs(**self.body)

            self.logger.debug(
                "Retrieving from: {} -- records: {}".format(retrieve, len(results))
            )

            self.request_results = results

            if output_format == "json":
                return Response(
                    json.dumps(
                        convertDatetime(dct=self.request_results),
                        indent=4,
                        sort_keys=True,
                        default=json_util.default,
                    ),
                    mimetype="application/json",
                )
            if output_format == "xml":
                return Response(dicttoxml(self.request_results), mimetype="text/xml")

    def validate_body(self):
        """
        Method for validating the request body.

        :return:
        :rtype:
        """

        # {
        #     "retrieve": "cves",  # retrieve from cves collection
        #     "dict_filter": {
        #         "vulnerable_configuration": "cpe:2.3:o:microsoft:windows_7:*:sp1:*:*:*:*:*:*"
        #     },  # filter according to pymongo docs
        #     "limit": 10,  # limit returned results
        #     "sort": "cvss",  # sort on this field
        #     "sort_dir": "ASC",  # sorting direction ASC = pymongo.ASCENDING, DESC = pymongo.DESCENDING
        #     "query_filter": {
        #         "access": 0,
        #         "cwe": 0
        #     },  # query filter to exclude certain fields (via a 0) or to limit query to a specific set (via a 1)
        #     "skip": 25,  # skip the first xx entries, 25 entries in this case
        #     "output_format": "json"  # define the desired output format JSON by default, xml supported
        # }

        retrieve = ["capec", "cpe", "cves", "cwe"]

        sort_dir = ["ASC", "DESC"]

        required_keys = ["retrieve", "dict_filter"]

        output_format = ["json", "xml"]

        optional_keys = [
            "sort",
            "limit",
            "skip",
            "query_filter",
            "sort_dir",
            "output_format",
        ]

        if self.body is None or len(self.body) == 0:
            return (
                False,
                "Please send a proper request with a json formatted like in the documentation.",
            )

        if not all(key.lower() in self.body for key in required_keys):
            return False, "Request is missing one or more required keys!"

        if not self.body["retrieve"].lower() in retrieve:
            return False, "Unable to retrieve from specified data source!"

        if "sort_dir" in self.body.keys():
            if not self.body["sort_dir"] in sort_dir:
                return (
                    False,
                    "Specified sorting direction not possible; possible options are: {}!".format(
                        sort_dir
                    ),
                )

        if "output_format" in self.body.keys():
            if not self.body["output_format"] in output_format:
                return (
                    False,
                    "Specified output format is not possible; possible options are: {}!".format(
                        output_format
                    ),
                )

        all_keys = retrieve + required_keys + optional_keys

        if not all(key in all_keys for key in self.body):
            return False, "Request contains unknown keys!"

        return True, "Ok"
