import shutil
import sys
from abc import abstractmethod

from dateutil.parser import parse as parse_datetime

from lib.DatabaseLayer import getInfo
from lib.DownloadHandler import DownloadHandler
from lib.IJSONHandler import IJSONHandler


class JSONFileHandler(DownloadHandler):
    def __init__(self, feed_type, prefix):
        super().__init__(feed_type)

        self.prefix = prefix

        self.ijson_handler = IJSONHandler()

    def __repr__(self):
        """ return string representation of object """
        return "<< JSONFileHandler:{} >>".format(self.feed_type)

    def download_site(self, url):
        self.logger.debug("Downloading from url: {}".format(url))
        session = self.get_session()
        with session.get(url) as response:
            self.last_modified = parse_datetime(
                response.headers["last-modified"], ignoretz=True
            )

            self.logger.debug(
                "Last {} modified value: {}".format(self.feed_type, self.last_modified)
            )

            i = getInfo(self.feed_type.lower())

            if i is not None:
                if self.last_modified == i["last-modified"]:
                    self.logger.info(
                        "{}'s are not modified since the last update".format(
                            self.feed_type
                        )
                    )
                    sys.exit(0)

            content_type = response.headers["content-type"]

            self.logger.debug("URL: {} fetched Content-Type: {}".format(url, content_type))

            wd, filename = self.store_file(
                response_content=response.content, content_type=content_type, url=url
            )

            if filename is not None:
                self.file_to_queue((wd, filename))
            else:
                self.logger.error(
                    "Unable to retrieve a filename; something went wrong during the storing of the file"
                )
                sys.exit(1)

    def file_to_queue(self, file_tuple):

        working_dir, filename = file_tuple

        for cpe in self.ijson_handler.fetch(filename=filename, prefix=self.prefix):
            self.process_item(item=cpe)

        try:
            self.logger.debug("Removing working dir: {}".format(working_dir))
            shutil.rmtree(working_dir)
        except Exception as err:
            self.logger.error(
                "Failed to remove working dir; error produced: {}".format(err)
            )

    @abstractmethod
    def process_item(self, **kwargs):
        raise NotImplementedError

    @abstractmethod
    def update(self, **kwargs):
        raise NotImplementedError

    @abstractmethod
    def populate(self, **kwargs):
        raise NotImplementedError
