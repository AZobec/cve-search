#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Database layer
#  Abstraction layer between the database and the rest of the project
#
# Software is free software released under the "Modified BSD license"
#
# Copyright (c) 2014-2017       Pieter-Jan Moreels - pieterjan.moreels@gmail.com

# Imports
import uuid

from collections   import defaultdict
from passlib.hash  import pbkdf2_sha256

from lib.Config    import Configuration as conf
from lib.Database  import Database
from lib.Objects   import CPE, CWE, CAPEC
from lib.Singleton import Singleton
from lib.Toolkit   import toStringFormattedCPE

# Code
class DatabaseLayer(metaclass=Singleton):
  def __init__(self, hash_rounds = 8000, salt_size = 10, _db=None):
    self.hash_rounds = hash_rounds
    self.salt_size   = salt_size

    self.db        = _db and Database(db=_db) or Database()
    self.CPE       = CPEs()
    self.CWE       = CWEs()
    self.CAPEC     = CAPECs()
    self.Whitelist = MarkList('whitelist')
    self.Blacklist = MarkList('blacklist')
    self.Users     = Users()

####################
# Black-/Whitelist #
####################
class MarkList:
  def __init__(self, marktype):
    if marktype.lower() not in ['blacklist', 'whitelist']:
      raise ValueError()
    self.marktype = marktype.lower()
    self.db = Database()

  def get(self):
    return list(getattr(self.db, self.marktype+"_get")())

  def size(self):
    return getattr(self.db, self.marktype+"_size")()

  def contains(self, cpe):
    return getattr(self.db, self.marktype+"_contains")(cpe)

  def insert(self, cpe, cpeType, comments=None):
    # Strip all comments
    try:
      if '#' in cpe:
        if comments is None: comments = []
        comments.extend(cpe.split('#')[1:])
        cpe = cpe.split('#')[0]
      # Format properly
      if cpeType.lower() == 'cpe': cpe = toStringFormattedCPE(cpe)
      # Checks format
      if cpe:
        if not self.contains(cpe):
          getattr(self.db, self.marktype+"_insert")(cpe, cpeType, comments)
          return True
      return False
    except Exception as ex:
      print("Error inserting item in database: %s"%ex)
      raise(ex)

  def remove(self, cpe):
    try:
      cpe = toStringFormattedCPE(cpe.strip())
      if cpe and self.contains(cpe):
        getattr(self.db, self.marktype+"_remove")(cpe)
        return True
      return False
    except Exception as ex:
      print("Error removing item from database: %s"%ex)
      raise(ex)

  def update(self, cpeOld, cpeNew, cpeType):
    try:
      comments = cpeNew.split("#")[1:]
      if cpeType == "cpe":
        cpeOld = toStringFormattedCPE(cpeOld.split('#')[0].strip())
        cpeNew = toStringFormattedCPE(cpeNew.split('#')[0].strip())
      if cpeOld and cpeNew:
        if self.contains(cpeOld):
          if self.contains(cpeNew) and cpeNew != cpeOld:
            raise(Exception("Value already exists in database"))
          getatrr(self.db, self.marktype+"_update")(cpeOld, cpeNew, cpeType, comments)
          return True
      return False
    except Exception as ex:
      print("Error updating item in database: %s"%(ex))
      raise(ex)

  def clear(self):
    try:
      size = self.size()
      getattr(self.db, self.marktype+"_drop")
      return size
    except Exception as ex:
      print("Error cleaning out collection in database: %s"%(ex))
      raise(ex)

#########
# Users #
#########
class Users:
  def __init__(self):
    self.db = Database()

  def size(self):
    return self.db.user_size()

  def insert(self, user, passwd, admin=False, localOnly=False):
    hashed = pbkdf2_sha256.encrypt(passwd, **conf.getPBKDFSettings())
    data = {'username': user, 'password': hashed}
    if admin:     data['master']     = True
    if localOnly: data['local_only'] = True
    self.db.user_add(data)

  def remove(self, username):
    self.db.user_remove(username)

  def changePassword(self, username, pwd):
    user   = self.get(username)
    if user:
      hashed = pbkdf2_sha256.encrypt(pwd, **conf.getPBKDFSettings())
      user['password'] = hashed
      self.db.user_update(user)
      return True
    return False

  def setAdmin(self, username, admin=True):
    self.db.user_setAdmin(username, admin)

  def isAdmin(self, username):
    user = self.get(username)
    return (user and user.get('master'))

  def isOnlyAdmin(self, username):
    return self.db.user_isOnlyAdmin(username)

  def setLocalOnly(self, username, localOnly=True):
    self.db.user_setLocalOnly(username, localOnly)

  def isLocalOnly(self, username):
    user = self.get(username)
    return (user and user.get('local_only'))

  def isOnlyMaster(self, username):
    return self.db.user_isOnlyAdmin(username)

  def exists(self, username):
    return True if self.get(username) else False

  def get(self, username):
    return self.db.user_get(username)

  def getAll(self):
    return self.db.user_getAll()

  def verifyPassword(self, username, pwd):
    user = self.get(username)
    return (user and pbkdf2_sha256.verify(pwd, user['password']))

  def getToken(self, username):
    user = self.get(username)
    if not user:               return None
    if 'token' in user.keys(): return user['token']
    else:                      return self.generateToken(user)

  def generateToken(self, username):
    user = self.get(username)
    if user:
      user['token'] = uuid.uuid4().hex
      self.db.user_update(user)
      return user['token']
    return None

########
# CVEs #
########
class CVEs:
  def __init__(self):
    self.db = Database()

  def upsert(self, cve):
    if not isinstance(cve, list):
      cve = [cve]
    if not all(isinstance(x, CVE) for x in cve):
      raise ValueError()
    self.db.upsertCVE(cve)

  # Data retrieval
  def get(self, cveID):
    return self.db.getCVE(cveID)

  def forCPE(self, cpe):
    return self.db.cvesForCPE(cpe)

  # Info
  def info(self):
    return self.db.getCVEInfo()

  def updated(self, date=None):
    if date:
      self.db.cve_setUpdate(date)
    else:
      return self.db.cve_getUpdate()

########
# CPEs #
########
class CPEs:
  def __init__(self):
    self.db = Database()

  def upsert(self, cpe):
    if not isinstance(cpe, list):
      cpe = [cpe]
    if not all(isinstance(x, CPE) for x in cpe):
      raise ValueError()
    self.db.cpe_upsert(cpe)

  def get(self, id):
    cpe = self.db.cpe_get(toStringFormattedCPE(id))
    return cpe if cpe else CPE(id)

  def getAll(self):
    return self.db.cpe_getAll()

  def updated(self, date=None):
    if date:
      self.db.cpe_setUpdate(date)
    else:
      return self.db.cpe_getUpdate()

########
# CWEs #
########
class CWEs:
  def __init__(self):
    self.db  = Database()
    self.cwe = None

  def upsert(self, cwe):
    if not isinstance(cwe, list):
      cwe = [cwe]
    if not all(isinstance(x, CWE) for x in cwe):
      raise ValueError()
    self.db.cwe_upsert(cwe)

  def updated(self, date=None):
    if date:
      self.db.cwe_setUpdate(date)
    else:
      return self.db.cwe_getUpdate()

  def get(self, id):
    if type(id) is int: id = str(id)
    if not self.cwe: self._populate_memory_db()
    return self.cwe.get(id)

  def _populate_memory_db(self):
    self.cwe = {x.id: x for x in self.db.cwe_getAll()}
    for c in self.cwe.values():
      c.capec = DatabaseLayer().CAPEC.relatedTo(c.id)


#########
# CAPEC #
#########
class CAPECs:
  def __init__(self):
    self.db      = Database()
    self.capec   = None
    self.related = None

  def upsert(self, capec):
    if not isinstance(capec, list):
      capec = [capec]
    if not all(isinstance(x, CAPEC) for x in capec):
      raise ValueError()
    self.db.capec_upsert(capec)

  def updated(self, date=None):
    if date:
      self.db.capec_setUpdate(date)
    else:
      return self.db.capec_getUpdate()

  def get(self, id):
    if type(id) is int: id = str(id)
    if not self.capec: self._populate_memory_db()
    return self.capec.get(id)

  def relatedTo(self, cweID):
    if type(cweID) is int: cweID = str(cweID)
    if not self.related: self._populate_memory_db()
    return self.related.get(cweID)

  def _populate_memory_db(self):
    self.capec   = {x.id: x for x in self.db.capec_getAll()}
    self.related = defaultdict(list)
    for c in self.capec.values():
      related_weaknesses = []
      for w in c.weaknesses:
        rw = DatabaseLayer().CWE.get(w) or CWE(w, "Unknown", "No CWE", "Unknown", "Unknown")
        related_weaknesses.append(rw)
        self.related[w].append(c)
      c.weaknesses = related_weaknesses
