import bson
from pymongo import DESCENDING, ASCENDING
from pymongo.collection import Collection

from lib.ApiRequests import JSONApiRequest
from lib.Config import Configuration


class MongoPlugin(Collection):
    def __init__(self, database, name, **kwargs):
        """
        Custom MongoDBPlugin for reaper project

        :param database: Database store to connect to
        :type database: MongoClient database connection
        :param name: Collection name to connect to
        :type name: str
        :param kwargs: Kwargs
        :type kwargs: dict
        """
        super().__init__(database, name, **kwargs)

    def query_docs(
        self,
        dict_filter={},
        sort=None,
        limit=None,
        skip=0,
        query_filter=None,
        sort_dir="DESC",
        id_to_string=True,
    ):
        """
        Method used to perform a extended query against the database in order to fetch documents.

        :param dict_filter: dict representing a filter see pyMongo doc
        :type dict_filter: dict
        :param sort: Field to sort on or list of tuples of field and direction
                    [("field", pymongo.DESCENDING), ("field2", pymongo.DESCENDING)]
        :type sort: list
        :param limit: Can be used to limit the amount of returned results
        :type limit: int
        :param skip: Can be used to skip the first x records of the returned results
        :type skip: int
        :param query_filter: Dict to include fields to return in the query results (e.g.: {field1: 1, field2: 1})
        :type query_filter: dict
        :param sort_dir: DESC (default) for DESCENDING, ASC for ASCENDING
        :type sort_dir: str
        :param id_to_string: Whether to convert mongodb '_id' from an ObjectId to a string
        :type id_to_string: bool
        :return: List of documents saved in the backend
        :rtype: list
        """
        documentlist = []

        if sort is not None:
            if isinstance(sort, str):
                if sort_dir == "DESC":
                    if limit is not None:
                        resultset = (
                            self.find(dict_filter, {"json": 0})
                            .sort(sort, DESCENDING)
                            .limit(limit)
                            .skip(skip)
                        )
                    else:
                        resultset = (
                            self.find(dict_filter, {"json": 0})
                            .sort(sort, DESCENDING)
                            .skip(skip)
                        )
                elif sort_dir == "ASC":
                    if limit is not None:
                        resultset = (
                            self.find(dict_filter, {"json": 0})
                            .sort(sort, ASCENDING)
                            .limit(limit)
                            .skip(skip)
                        )
                    else:
                        resultset = (
                            self.find(dict_filter, {"json": 0})
                            .sort(sort, ASCENDING)
                            .skip(skip)
                        )
            if isinstance(sort, list):
                if limit is not None:
                    resultset = (
                        self.find(dict_filter, {"json": 0})
                        .sort(sort)
                        .limit(limit)
                        .skip(skip)
                    )
                else:
                    resultset = (
                        self.find(dict_filter, {"json": 0}).sort(sort).skip(skip)
                    )
        else:
            if limit is not None:
                resultset = self.find(dict_filter, {"json": 0}).limit(limit).skip(skip)
            else:
                resultset = self.find(dict_filter, {"json": 0}).skip(skip)

        if query_filter is not None:
            if sort is not None:
                if isinstance(sort, str):
                    if limit is not None:
                        resultset = (
                            self.find(dict_filter, query_filter)
                            .sort(sort, DESCENDING)
                            .limit(limit)
                            .skip(skip)
                        )
                    else:
                        resultset = (
                            self.find(dict_filter, query_filter)
                            .sort(sort, DESCENDING)
                            .skip(skip)
                        )
                if isinstance(sort, list):
                    if limit is not None:
                        resultset = (
                            self.find(dict_filter, query_filter)
                            .sort(sort)
                            .limit(limit)
                            .skip(skip)
                        )
                    else:
                        resultset = (
                            self.find(dict_filter, query_filter).sort(sort).skip(skip)
                        )
            else:
                if limit is not None:
                    resultset = self.find(dict_filter, query_filter).limit(limit).skip(skip)
                else:
                    resultset = self.find(dict_filter, query_filter).skip(skip)

        if id_to_string:
            for doc in resultset:
                doc["_id"] = str(doc["_id"])
                documentlist.append(doc)
        else:
            for doc in resultset:
                documentlist.append(doc)

        return documentlist

    def fetch_one(self, dict_filter={}, query_filter=None, id_to_string=True):
        """
        The fetch one method wraps the original find_one method from pyMongo and turns the _id into a string.

        :param dict_filter: dict representing a filter see pyMongo doc
        :type dict_filter: dict
        :param query_filter: Dict with fields to exclude or include; e.g. {"hosts": 0} or {"hosts": 1}
        :type query_filter: dict
        :param id_to_string: Whether to convert mongodb '_id' from an ObjectId to a string
        :type id_to_string: bool
        :return: Dict with items from database or None
        :rtype: dict or None
        """

        if "_id" in dict_filter:
            if isinstance(dict_filter["_id"], str):
                dict_filter["_id"] = bson.objectid.ObjectId(dict_filter["_id"])
        if query_filter is not None:
            result = self.find_one(dict_filter, query_filter)
        else:
            result = self.find_one(dict_filter)

        if result is not None:
            if id_to_string:
                result["_id"] = str(result["_id"])

        return result


class DatabaseHandler(object):

    def __init__(self):
        self.config = Configuration()
        self.connection = self.config.getMongoConnection()

        for each in self.connection.list_collection_names():
            setattr(self, "store_{}".format(each), MongoPlugin(database=self.connection, name=each))

    def handle_api_json_query(self, request):
        if not isinstance(request, JSONApiRequest):
            raise TypeError("Wrong type recieved, expected JSONApiRequest but got: {}".format(type(request)))

        results = request.process(self)

        return results
