#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# API module of cve-search. Returns queries in JSON format
#
# Software is free software released under the "Modified BSD license"
#

# Copyright (c) 2013-2016 	Alexandre Dulaunoy - a@foo.be
# Copyright (c) 2014-2016 	Pieter-Jan Moreels - pieterjan.moreels@gmail.com

# imports
import json
import logging
import os
import random
import signal
import sys
import time
import urllib
_runPath = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.join(_runPath, ".."))

from bson               import json_util
from flask              import Flask, request, Response
from functools          import wraps
from logging.handlers   import RotatingFileHandler
from redis              import exceptions as redisExceptions
from tornado.httpserver import HTTPServer
from tornado.ioloop     import IOLoop
from tornado.wsgi       import WSGIContainer

import lib.CVEs          as cves
import lib.DatabaseLayer as db
import lib.Query         as query
import lib.Toolkit       as tk

from lib.Config import Configuration

class APIError(Exception):
  def __init__(self, message, status=500):
    self.message = message
    self.status  = status

class API():
  app = Flask(__name__, static_folder='static', static_url_path='/static')
  app.config['MONGO_DBNAME'] = Configuration.getMongoDB()
  app.config['SECRET_KEY'] = str(random.getrandbits(256))

  def __init__(self):
    routes = [{'r': '/api/cpe2.3/<path:cpe>',              'm': ['GET'], 'f': self.api_cpe23},
              {'r': '/api/cpe2.2/<path:cpe>',              'm': ['GET'], 'f': self.api_cpe22},
              {'r': '/api/cvefor/<path:cpe>',              'm': ['GET'], 'f': self.api_cvesFor},
              {'r': '/api/cve/<cveid>',                    'm': ['GET'], 'f': self.api_cve},
              {'r': '/api/cwe',                            'm': ['GET'], 'f': self.api_cwe},
              {'r': '/api/capec/<cweid>',                  'm': ['GET'], 'f': self.api_capec},
              {'r': '/api/last',                           'm': ['GET'], 'f': self.api_last},
              {'r': '/api/last/',                          'm': ['GET'], 'f': self.api_last},
              {'r': '/api/last/<int:limit>',               'm': ['GET'], 'f': self.api_last},
              {'r': '/api/browse',                         'm': ['GET'], 'f': self.api_browse},
              {'r': '/api/browse/',                        'm': ['GET'], 'f': self.api_browse},
              {'r': '/api/browse/<vendor>',                'm': ['GET'], 'f': self.api_browse},
              {'r': '/api/search/<vendor>/<path:product>', 'm': ['GET'], 'f': self.api_search},
              {'r': '/api/search/<path:search>',           'm': ['GET'], 'f': self.api_text_search},
              {'r': '/api/dbInfo',                         'm': ['GET'], 'f': self.api_dbInfo}]
    for route in routes: self.addRoute(route)

  def addRoute(self, route):
    self.app.add_url_rule(route['r'], view_func=route['f'], methods=route['m'])

  #############
  # Decorator #
  #############
  def api(funct):
    @wraps(funct)
    def api_wrapper(*args, **kwargs):
      data = error = None
      # Get data (and possibly errors)
      try:
        data = funct(*args, **kwargs)
      except APIError as e:
        error = {'status': 'error', 'reason': e.message}
      except:
        error = {'status': 'error', 'reason': 'Internal server error'}
      # Check if data should be returned as html or data
      try:
        if request.url_rule.rule.lower().startswith("/api/"):
          # Check API version for backwards compatibility. We'll call the old API v1.0
          if request.headers.get('Version') in ['1.1']:
            # Get the requested return type
            returnType = request.headers.get('Accept')
            # Default to JSON
            if   any(t in returnType for t in ['json', 'application/*', 'text/*', '*/*']):
              data = error if error else {'status': 'success', 'data': data}
            elif 'plain' in returnType:
              pass # No need to do anything, but needs to be accepted
            else:
              data = {'status': 'error', 'reason': 'Unknown Content-type requested'}
              returnType = 'application/json'
          data = json.dumps(data, indent=2, sort_keys=True, default=json_util.default)
          return Response(data, mimetype=returnType)
      except:
        pass
      if error: raise(APIError(error['reason']))
      return data
    return api_wrapper

  ##########
  # ROUTES #
  ##########
  # /api/cpe2.3/<cpe>
  @api
  def api_cpe23(self, cpe):
    cpe = tk.toStringFormattedCPE(cpe)
    return cpe if cpe else "None"

  # /api/cpe2.2/<cpe>
  @api
  def api_cpe22(self, cpe):
    cpe = tk.toOldCPE(cpe)
    return cpe if cpe else "None"

  # /api/cvefor/<cpe>
  @api
  def api_cvesFor(self, cpe):
    cpe  = urllib.parse.unquote_plus(cpe)
    cves = query.cvesForCPE(cpe)
    return cves

  # /api/cve/<cveid>
  @api
  def api_cve(self, cveid):
    cvesp = cves.last(rankinglookup=True, namelookup=True, via4lookup=True, capeclookup=True)
    cve = cvesp.getcve(cveid=cveid.upper())
    if not cve: raise(APIError('cve not found'), 404)
    return cve

  # /api/cwe
  @api
  def api_cwe(self):
    return db.getCWEs()

  # /api/capec/<cweid>
  @api
  def api_capec(self, cweid):
    return db.getCAPECFor(cweid)

  # /api/last
  # /api/last/
  # /api/last/<limit>
  @api
  def api_last(self, limit=None):
    limit = limit if limit else 30
    cvesp = cves.last(rankinglookup=True, namelookup=True, via4lookup=True, capeclookup=True)
    cve = cvesp.get(limit=limit)
    return cve

  # /api/browse
  # /api/browse/
  # /api/browse/<vendor>
  @api
  def api_browse(self, vendor=None):
    if vendor:
      vendor = urllib.parse.quote_plus(vendor).lower()
    try:
      browseList = query.getBrowseList(vendor)
    except redisExceptions.ConnectionError:
      raise(APIError("Server could not connect to the browsing repository"))
    if isinstance(browseList, dict):
      return browseList
    else:
      return {}

  # /api/search/<vendor>/<path:product>
  @api
  def api_search(self, vendor=None, product=None):
    if not (vendor and product): return {}
    search = vendor + ":" + product
    # Not using query.cvesForCPE, because that one gives too much info
    #return json.dumps(db.cvesForCPE(search), default=json_util.default)
    return db.cvesForCPE(search)

  # /api/search/<path:search>
  @api
  def api_text_search(self, search=None):
    return db.getSearchResults(search)

  # /api/dbInfo
  @api
  def api_dbInfo(self):
    return db.getDBStats()


  ########################
  # Web Server Functions #
  ########################
  # signal handlers
  def sig_handler(self, sig, frame):
    print('Caught signal: %s' % sig)
    IOLoop.instance().add_callback(self.shutdown)

  def shutdown(self):
    MAX_WAIT_SECONDS_BEFORE_SHUTDOWN = 3
    print('Stopping http server')
    self.http_server.stop()

    print('Will shutdown in %s seconds ...' % MAX_WAIT_SECONDS_BEFORE_SHUTDOWN)
    io_loop = IOLoop.instance()
    deadline = time.time() + MAX_WAIT_SECONDS_BEFORE_SHUTDOWN

    def stop_loop():
      now = time.time()
      if now < deadline and (io_loop._callbacks or io_loop._timeouts):
        io_loop.add_timeout(now + 1, stop_loop)
      else:
        io_loop.stop()
        print('Shutdown')
    stop_loop()

  def start(self):
    # get properties
    flaskHost = Configuration.getFlaskHost()
    flaskPort = Configuration.getFlaskPort()
    flaskDebug = Configuration.getFlaskDebug()
    # logging
    if Configuration.getLogging():
      logfile = Configuration.getLogfile()
      pathToLog = logfile.rsplit('/', 1)[0]
      if not os.path.exists(pathToLog):
        os.makedirs(pathToLog)
      maxLogSize = Configuration.getMaxLogSize()
      backlog = Configuration.getBacklog()
      file_handler = RotatingFileHandler(logfile, maxBytes=maxLogSize, backupCount=backlog)
      file_handler.setLevel(logging.ERROR)
      formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
      file_handler.setFormatter(formatter)
      self.app.logger.addHandler(file_handler)

    if flaskDebug:
      # start debug flask server
      self.app.run(host=flaskHost, port=flaskPort, debug=flaskDebug)
    else:
      # start asynchronous server using tornado wrapper for flask
      # ssl connection
      print("Server starting...")
      if Configuration.useSSL():
        ssl_options = {"certfile": os.path.join(_runPath, "../", Configuration.getSSLCert()),
                        "keyfile": os.path.join(_runPath, "../", Configuration.getSSLKey())}
      else:
        ssl_options = None
      signal.signal(signal.SIGTERM, self.sig_handler)
      signal.signal(signal.SIGINT,  self.sig_handler)

      self.http_server = HTTPServer(WSGIContainer(app), ssl_options=ssl_options)
      self.http_server.bind(flaskPort, address=flaskHost)
      self.http_server.start(0)  # Forks multiple sub-processes
      IOLoop.instance().start()


if __name__ == '__main__':
  server = API()
  server.start()
