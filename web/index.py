#!/usr/bin/env python3.3
# -*- coding: utf-8 -*-
#
# Simple web interface to cve-search to display the last entries
# and view a specific CVE.
#
# Software is free software released under the "Modified BSD license"
#

# Copyright (c) 2013-2014 Alexandre Dulaunoy - a@foo.be
# Copyright (c) 2014      Pieter-Jan Moreels - pieterjan.moreels@gmail.com
from flask import Flask
from flask import render_template, url_for
from flask.ext.pymongo import PyMongo
import sys
sys.path.append("../lib/")
import cves
import redis
import pymongo
from datetime import datetime
from dateutil import tz
import dateutil.parser
import os
import base64
import re
import argparse
sys.path.append("..")
from db_whitelist import importList
from db_whitelist import dropDb
from db_whitelist import countItems

# parse command line arguments
argparser = argparse.ArgumentParser(description='populate/update the whitelist used in webviews')
argparser.add_argument('-v', action='store_true', help='verbose output')
args = argparser.parse_args()

app = Flask(__name__, static_folder='static', static_url_path='/static')
app.config['MONGO_DBNAME'] = 'cvedb'
mongo = PyMongo(app)

@app.route('/cve/<cveid>')
def cve(cveid):
    cvesp = cves.last(rankinglookup = True, namelookup = True, vfeedlookup = True)
    cve = cvesp.getcve(cveid=cveid)
    if cve is None:
        return page_not_found(404)
    return render_template('cve.html', cve=cve)

@app.route('/')
def last():
    cvesp = cves.last(rankinglookup = True, namelookup = True, vfeedlookup = True)
    cve = cvesp.get(limit=50)

    return render_template('index.html', cve=cve, r=0)

@app.route('/r/<int:r>')
def lastrange(r):
    if not r:
        r = 0
    cvesp = cves.last(rankinglookup = True, namelookup = True, vfeedlookup = True)
    cve = cvesp.get(limit=50, skip=r)
    return render_template('index.html', cve=cve, r=r)

@app.route('/browse/<vendor>/<product>')
@app.route('/browse/<vendor>')
@app.route('/browse/')
def browse(vendor=None,product=None):
    r = redis.StrictRedis(host='localhost', port=6379, db=10)
    if vendor is None:
        v1 = r.smembers("t:/o")
        v2 = r.smembers("t:/a")
        v3 = r.smembers("t:/h")
        vendor = sorted(list(set(list(v1)+list(v2)+list(v3))))
        cpe=None
    else:
        cpenum = r.scard("v:"+vendor)
        if cpenum < 1:
            return page_not_found(404)
        p = r.smembers("v:"+vendor)
        cpe = sorted(list(p))

    return render_template('browse.html', cpe=cpe, vendor=vendor, product=product)

def whitelist_logic(cve):
    # get the whitelist
    connect = pymongo.Connection()
    db = connect.cvedb
    collection = db.mgmt_whitelist
    whitelist = collection.find()
    whitelistitems = []
    for whitelistid in whitelist:
        whitelistitems.append(whitelistid['id'])

    # check the cpes (full or partially) in the whitelist
    for cveid in cve:
        cpes=cveid['vulnerable_configuration']
        if len([i for e in whitelistitems for i in cpes if e in i])>0:
            cve[cve.index(cveid)]['whitelisted'] = 'yes'
    return cve

def blacklist_logic(cve):
    # get the whitelist
    blacklist = getBlacklist()
    blacklistitems = []
    for blacklistid in blacklist:
        blacklistitems.append(blacklistid['id'])
    # check the cpes (full or partially) in the blacklist
    for cveid in cve:
        cpes=cveid['vulnerable_configuration']
        if len([i for e in blacklistitems for i in cpes if e in i])>0:
            cve[cve.index(cveid)]['blacklisted'] = 'yes'
    return cve

def mycpes():
    connect = pymongo.Connection()
    db = connect.cvedb
    collection = db.mgmt_whitelist
    res = collection.find({}, {'_id': 0});
    res.count()
    cpes = []
    for item in  res:
        cpes.append(item['id'])
    return cpes

def mycves(limit=5, skip=0):
    connect = pymongo.Connection()
    db = connect.cvedb
    collection = db.cves
    cpes = mycpes()
    entries = []
    for item in collection.find({ 'vulnerable_configuration': { '$in' : cpes } } ).sort("Modified",-1).skip(skip).limit(limit):
        entries.append(item)
    return (entries)

@app.route('/whitelist')
def whitelist():
    cvesp = cves.last(rankinglookup = True, namelookup = True, vfeedlookup = True)
    cve = cvesp.get(limit=50)
    cve=whitelist_logic(cve)
    return render_template('whitelist.html', cve=cve, r=0)

@app.route('/whitelist/r/<int:r>')
def whitelistlast(r):
    if not r:
        r = 0
    cvesp = cves.last(rankinglookup = True, namelookup = True, vfeedlookup = True)
    cve = cvesp.get(limit=50, skip=r)
    cve=whitelist_logic(cve)
    return render_template('whitelist.html', cve=cve, r=r)

@app.route('/mycve')
def mycvelist():
    cve = mycves(limit=50)
    cve = blacklist_logic(cve)
    return render_template('mycve.html', cve=cve, r=0)

@app.route('/mycve/r/<int:r>')
def mycvelistlast(r):
    if not r:
        r = 0
    cve = mycves(limit=50, skip=r)
    cve = blacklist_logic(cve)
    return render_template('mycve.html', cve=cve, r=r)

@app.route('/admin')
def admin():
    return render_template('admin.html', status="default")

@app.route('/admin/updatedb')
def updatedb():
    os.system("cd ..; python3 db_updater.py -civ")
    return render_template('admin.html', status="db_updated")

@app.route('/admin/whitelist/import/<force>/<path>')
def whitelistImport(force=None, path=None):
    path = base64.b64decode(path).decode('utf-8')
    pattern = re.compile('^([a-z/ 0-9._-])+$')
    if pattern.match(path):
        count = countItems()
        if (count == 0) | (force == "f"):
            dropDb()
            importList(path)
            status="wl_imported"
        else:
            status="wl_already_filled"
    else:
        status="invalid_path"
    return render_template('admin.html', status=status)

@app.route('/search/<vendor>/<product>')
def search(vendor=None,product=None):

    connect = pymongo.Connection()
    db = connect.cvedb
    collection = db.cves
    search = vendor+":"+product
    cve = collection.find({"vulnerable_configuration": {'$regex': search}}).sort("Modified",-1)
    return render_template('search.html', cve=cve)

@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404

@app.template_filter('currentTime')
def currentTime(utc):
    timezone = tz.tzlocal()
    utc = dateutil.parser.parse(utc)
    output = utc.astimezone(timezone)
    output = output.strftime('%d-%m-%Y - %H:%M')
    return output 

if __name__ == '__main__':
        app.run(debug=True)
